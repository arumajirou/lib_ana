ID,Parent,Type,Name,Path,Module,Docstring,Params,ReturnType
16,15,function,_distance_to_holiday,timesfm.time_features._distance_to_holiday,timesfm.time_features,Return distance to given holiday.,"[{'name': 'holiday', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
37,36,function,create_quantiles,timesfm.pytorch_patched_decoder.create_quantiles,timesfm.pytorch_patched_decoder,,[],list[float]
39,36,function,_masked_mean_std,timesfm.pytorch_patched_decoder._masked_mean_std,timesfm.pytorch_patched_decoder,"Calculates mean and standard deviation of `inputs` across axis 1.\n\nIt excludes values where `padding` is 1.\n\nArgs:\n inputs: A PyTorch tensor of shape [b, n, p].\n padding: A PyTorch tensor of shape [b, n, p] with values 0 or 1.\n\nReturns:\n A tuple containing the mean and standard deviation.\n We return the statistics of the first patch with more than three non-padded\n values.","[{'name': 'inputs', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}, {'name': 'padding', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}]","tuple[torch.Tensor, torch.Tensor]"
40,36,function,_shift_padded_seq,timesfm.pytorch_patched_decoder._shift_padded_seq,timesfm.pytorch_patched_decoder,"Shifts rows of seq based on the first 0 in each row of the mask.\n\nArgs:\n mask: mask tensor of shape [B, N]\n seq: seq tensor of shape [B, N, P]\n\nReturns:\n Returns the shifted sequence.","[{'name': 'mask', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}, {'name': 'seq', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}]",torch.Tensor
41,36,function,get_large_negative_number,timesfm.pytorch_patched_decoder.get_large_negative_number,timesfm.pytorch_patched_decoder,Returns a large negative value for the given dtype.,"[{'name': 'dtype', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.dtype', 'has_default': False, 'default_repr': ''}]",torch.Tensor
42,36,function,apply_mask_to_logits,timesfm.pytorch_patched_decoder.apply_mask_to_logits,timesfm.pytorch_patched_decoder,Applies a floating-point mask to a set of logits.\n\nArgs:\n logits: A torch.Tensor of logit values.\n mask: A torch.Tensor (float32) of mask values with the encoding described\n in the function documentation.\n\nReturns:\n Masked logits.,"[{'name': 'logits', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}, {'name': 'mask', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}]",torch.Tensor
43,36,function,convert_paddings_to_mask,timesfm.pytorch_patched_decoder.convert_paddings_to_mask,timesfm.pytorch_patched_decoder,"Converts binary paddings to a logit mask ready to add to attention matrix.\n\nArgs:\n paddings: binary torch.Tensor of shape [B, T], with 1 denoting padding\n token.\n dtype: data type of the input.\n\nReturns:\n A torch.Tensor of shape [B, 1, 1, T] ready to add to attention logits.","[{'name': 'paddings', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}, {'name': 'dtype', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.dtype', 'has_default': True, 'default_repr': 'torch.float32'}]",torch.Tensor
44,36,function,causal_mask,timesfm.pytorch_patched_decoder.causal_mask,timesfm.pytorch_patched_decoder,"Computes and returns causal mask.\n\nArgs:\n input_t: A torch.Tensor of shape [B, T, D].\n\nReturns:\n An attention_mask torch.Tensor of shape [1, 1, T, T]. Attention mask has\n already been converted to large negative values.","[{'name': 'input_t', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}]",torch.Tensor
45,36,function,merge_masks,timesfm.pytorch_patched_decoder.merge_masks,timesfm.pytorch_patched_decoder,"Merges 2 masks.\n\nlogscale mask is expected but 0/1 mask is also fine.\n\nArgs:\n a: torch.Tensor of shape [1|B, 1, 1|T, S].\n b: torch.Tensor of shape [1|B, 1, 1|T, S].\n\nReturns:\n torch.Tensor of shape [1|B, 1, 1|T, S].","[{'name': 'a', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}, {'name': 'b', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'torch.Tensor', 'has_default': False, 'default_repr': ''}]",torch.Tensor
103,102,function,_unnest,timesfm.xreg_lib._unnest,timesfm.xreg_lib,,"[{'name': 'nested', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'Sequence[Sequence[Any]]', 'has_default': False, 'default_repr': ''}]",np.ndarray
104,102,function,_repeat,timesfm.xreg_lib._repeat,timesfm.xreg_lib,,"[{'name': 'elements', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'Iterable[Any]', 'has_default': False, 'default_repr': ''}, {'name': 'counts', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'Iterable[int]', 'has_default': False, 'default_repr': ''}]",np.ndarray
105,102,function,_to_padded_jax_array,timesfm.xreg_lib._to_padded_jax_array,timesfm.xreg_lib,,"[{'name': 'x', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'np.ndarray', 'has_default': False, 'default_repr': ''}]",jax.Array
121,120,function,_shift_padded_seq,timesfm.patched_decoder._shift_padded_seq,timesfm.patched_decoder,Shifts rows of seq based on the first 0 in each row of the mask.,"[{'name': 'mask', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'JTensor', 'has_default': False, 'default_repr': ''}, {'name': 'seq', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'JTensor', 'has_default': False, 'default_repr': ''}]",JTensor
125,120,function,_masked_mean_std,timesfm.patched_decoder._masked_mean_std,timesfm.patched_decoder,"Calculates mean and standard deviation of arr across axis 1.\n\nIt should exclude values where pad is 1.\n\nArgs:\n inputs: A JAX array of shape [b, n, p].\n padding: A JAX array of shape [b, n, p] with values 0 or 1.\n\nReturns:\n A tuple containing the mean and standard deviation of arr. We return the\n statistics of the first patch with more than three non-padded values.","[{'name': 'inputs', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'JTensor', 'has_default': False, 'default_repr': ''}, {'name': 'padding', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'JTensor', 'has_default': False, 'default_repr': ''}]","Tuple[JTensor, JTensor]"
126,120,function,_create_quantiles,timesfm.patched_decoder._create_quantiles,timesfm.patched_decoder,Returns the quantiles for forecasting.,[],list[float]
160,159,function,process_group,timesfm.timesfm_base.process_group,timesfm.timesfm_base,,"[{'name': 'key', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}, {'name': 'group', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}, {'name': 'value_name', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}, {'name': 'forecast_context_len', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
161,159,function,moving_average,timesfm.timesfm_base.moving_average,timesfm.timesfm_base,Calculates the moving average using NumPy's convolution function.,"[{'name': 'arr', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}, {'name': 'window_size', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
162,159,function,freq_map,timesfm.timesfm_base.freq_map,timesfm.timesfm_base,Returns the frequency map for the given frequency string.,"[{'name': 'freq', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': 'str', 'has_default': False, 'default_repr': ''}]",
163,159,function,strip_leading_nans,timesfm.timesfm_base.strip_leading_nans,timesfm.timesfm_base,"Removes contiguous NaN values from the beginning of a NumPy array.\n\nArgs:\n arr: The input NumPy array.\n\nReturns:\n A new NumPy array with leading NaN values removed.\n If the array is all NaNs or empty, returns an empty array.","[{'name': 'arr', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
164,159,function,linear_interpolation,timesfm.timesfm_base.linear_interpolation,timesfm.timesfm_base,"Performs linear interpolation to fill NaN values in a 1D numpy array.\n\nArgs:\n arr: The 1D numpy array containing NaN values.\n\nReturns:\n A new numpy array with NaN values filled using linear interpolation, \n or the original array if no NaNs are present. \n Returns None if the input is not a 1D array.\n Returns the original array if there are no NaN values.","[{'name': 'arr', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
165,159,function,_normalize,timesfm.timesfm_base._normalize,timesfm.timesfm_base,,"[{'name': 'batch', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
166,159,function,_renormalize,timesfm.timesfm_base._renormalize,timesfm.timesfm_base,,"[{'name': 'batch', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}, {'name': 'stats', 'kind': 'POSITIONAL_OR_KEYWORD', 'annotation': '', 'has_default': False, 'default_repr': ''}]",
